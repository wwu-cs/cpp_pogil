 {\bf\large Model 5: Recursive Programs to Estimate $\pi$} \\[-15pt]
  \begin{center}
    \begin{tabular}{p{2.7in}p{0.2in}p{2.7in}}
      \begin{minipage}{2.7in}
        \scriptsize A Recursive Python Program
        \begin{minted}[
          frame=lines,
          framesep=2mm,
          bgcolor=gray!15,
          baselinestretch=1.2,
          linenos
        ]{Python}
# Python function to estimate pi
def estimatePi(terms):
  if ( terms <= 0 ): return 0.0
  val = 4.0 / (2*terms - 1)
  if (terms % 2 == 0): val *= -1
  return val + estimatePi(terms-1)
  
# Function to test estimatePi
def testEstimatePi():
  vals = [ -1, 0, 1, 2, 10, 100 ]
  for i in vals: print i, estimatePi(i)
  
testEstimatePi()
        \end{minted}
        \par\vskip 40pt\null
      \end{minipage}
      & &
      \begin{minipage}{2.7in}
        \scriptsize A Scheme / LISP Program
        \begin{minted}[
          frame=lines,
          framesep=2mm,
          bgcolor=gray!15,
          baselinestretch=1.2,
          linenos
        ]{scheme}
; Scheme function to estimate pi
(define estimatePi
  (lambda (terms)
    (if (<= terms 0)
      0
      (+ (estimatePi (- terms 1))
        (/ (if (odd? terms) +4 -4)
          (+ terms terms -1)
          )))))
        
; Function to test estimatePi
(define testEstimatePi
  (lambda ()
    (define vals `(-1 0 1 2 10 100))
    (map estimatePi vals)   
  ))
  
(testEstimatePi)
        \end{minted}
      \end{minipage}
    \end{tabular}
  \end{center}    
      
  {\it\large Refer to Model 5 above as your team develops consensus answers
    to the questions below.}

  \item The Python code above estimates $\pi$ using the same series,
    but with a different approach.  Answer the following questions based
    on the {\it Python} code above.
    \par\vskip 15pt
    
    \begin{enumerate}[(a)]
      \itemsep 15pt
      \item What variable(s) are defined in the {\tt testEstimatePi()} function?
        \hfill\fillin[{\tt vals} and {\tt i}][1.5in]
      \item What function is called by {\tt testEstimatePi()}?
        \hfill\fillin[{\tt estimatePi()}][1.5in]             
      \item What variable(s) are defined in the {\tt estimatePi()} function?
        \hfill\fillin[{\tt terms} and {\tt val}][1.5in]
      \item What function is called by {\tt estimatePi()}?
        \hfill\fillin[\tt estimatePi()][1.5in]       
      \item When {\tt estimatePi(0)} is called, what value is returned?
        \hfill\fillin[\tt 0.0][1.5in]
      \item When {\tt estimatePi(1)} is called, what function call is made on line 6?
        \hfill\fillin[\tt estimatePi(0)][1.5in]
      \item When {\tt estimatePi(1)} is called, what value is returned?
        \hfill\fillin[\tt 4.0/1 + 0.0 = 4.0][1.5in]
      \item When {\tt estimatePi(2)} is called, what function call is made on line 6?
        \hfill\fillin[\tt estimatePi(1)][1.5in]
      \item When {\tt estimatePi(2)} is called, what value is returned?
        \hfill\fillin[\tt -4.0/3 + 4.0 = 2.6667][1.5in]
    \end{enumerate}
      
  \item A function that calls itself is called a {\it recursive}
    function.  While possibly confusing at first, recursive functions
    can be both powerful and flexible.  Which function(s) in the {\it
    Python} code above is recursive?
    \ifprintanswers\vskip -20pt\null\fi
    \begin{solution}[0.5in]
      The function {\tt estimatePi()}
    \end{solution}
    
\newpage

  \item If recursive function {\it always} calls itself it will never
    end, and eventually the computer will run out of memory.  Situations
    when a recursive function {\it does} call itself are called {\it
    recursive cases} and those when it {\it does not} are called
    {\it base cases}.  What are the base and recursive cases
    for the function {\tt estimatePi()}?
    \ifprintanswers\vskip -20pt\null\fi
    \begin{solution}[0.5in]
      The base case is when {\tt terms = 0}, everything else is a recursive case.
    \end{solution}
    \ifprintanswers\vskip -35pt\null\fi

  \item The {\it Scheme} language is a dialect of the {\it LISP}
    (short for LISt Processing) language, which\key\\[-2.5mm] was developed in the
    1970's by Guy Steele and Gerald Sussman for artificial intelligence.
    Ideally, in Scheme programs the value of a variable never changes,
    and functions always return something useful.  Thus, Scheme is
    called a {\it functional language}.  Scheme also uses {\it
    recursion} (functions that call themselves) instead of loops.
    Answer the following questions based on the {\it Scheme} code above.
    \par\vskip 15pt
    
    \begin{enumerate}[(a)]
      \itemsep 15pt
      \item What marks a comment in {\it Scheme}?
        \hfill\fillin[\tt ;][1.5in] 
      \item What keyword assigns a value to a name?
        \hfill\fillin[\tt define][1.5in]             
      \item What keyword defines a function?
        \hfill\fillin[\tt lambda][1.5in]
      \item What expression subtracts 1 from {\tt terms}?
        \hfill\fillin[\tt (- terms 1)][1.5in]       
      \item What expression checks whether {\tt terms} is odd?
        \hfill\fillin[\tt (odd? terms) ][1.5in]
      \item If that expression evaluates to true, what value is returned?
        \hfill\fillin[\tt +4][1.5in]
      \item If that expression evaluates to false, what value is returned?
        \hfill\fillin[\tt -4][1.5in]
      \item When {\tt estimatePi(2)} is called, what function call is made?
        \hfill\fillin[\tt estimatePi(1)][1.5in]
    \end{enumerate}
    
  \item You'll notice that Scheme uses parentheses quite a bit.  Some
    people jokingly claim that ``LISP'' stands for ``Lost In Stupid
    Parentheses''. How many pairs of parentheses are used in
    defining each of the functions {\tt estimatePi} and {\tt testEstimatePi}?
    \ifprintanswers\vskip -20pt\null\fi
    \begin{solution}[0.75in]
      There are 11 pairs of parentheses in {\tt estimatePi} and 6 in {\tt testEstimatePi}.
    \end{solution}
    \ifprintanswers\vskip -35pt\null\fi

  \item An online {\tt Scheme} interpreter is available at
    \url{https://repl.it/languages/scheme}.  Copy the Scheme code
    from {\tt activity19.scm} into this interpreter and run it. Then determine the 
    approximation of $\pi$ with 10000 terms by adding 10000 to the
    list of test values.
    \ifprintanswers\vskip -20pt\null\fi
    \begin{solution}[1in]
      Change line 14 to \mintinline{scheme}|(define vals `(-1 0 1 2 10 100 10000))|
      and we get the estimate 3.131592035585537 with 10000 terms.
    \end{solution}
    \ifprintanswers\vskip -35pt\null\fi