\model{Recursive Programs to Estimate $\pi$}
  \begin{center}
    \begin{tabular}{p{2.7in}p{0.2in}p{2.7in}}
      \begin{minipage}{2.7in}
        \scriptsize A Recursive Python Program
        \begin{pythlst}
# Function to estimate pi using recursion
def estimatePi(terms):
    if terms <= 0:
        return 0.0
    
    val = 4.0 / (2 * terms - 1)
    if terms % 2 == 0:
        val *= -1
    
    return val + estimatePi(terms - 1)

# Function to test estimatePi
def testEstimatePi():
    vals = [-1, 0, 1, 2, 10, 100]
    for i in vals:
        print(i, estimatePi(i))

if __name__ == "__main__":
    testEstimatePi()
        \end{pythlst}
      \end{minipage}
      & &
      \begin{minipage}{2.7in}
        \scriptsize A Scheme / LISP Program
        \begin{pythlst}
; Scheme function to estimate pi
(define estimatePi
  (lambda (terms)
    (if (<= terms 0)
      0
      (+ (estimatePi (- terms 1))
        (/ (if (odd? terms) +4 -4)
          (+ terms terms -1)
          )))))
        
; Function to test estimatePi
(define testEstimatePi
  (lambda ()
    (define vals `(-1 0 1 2 10 100))
    (map estimatePi vals)   
  ))
  
(testEstimatePi)
        \end{pythlst}
      \end{minipage}
    \end{tabular}
  \end{center}    
      
  {\it\large Refer to Model 5 above as your team develops consensus answers
    to the questions below.}

  \quest{10 min}

  \Q The Python code above estimates $\pi$ using the same series,
    but with a different approach.  Answer the following questions based
    on the {\it Python} code above.  
    \begin{enumerate}
      \itemsep 10pt
      \item What variable(s) are defined in the {\tt testEstimatePi()} function?
        \hfill\ans[1.5in]{{\tt vals} and {\tt i}}

      \item What function is called by {\tt testEstimatePi()}?
        \hfill\ans[1.5in]{{\tt estimatePi()}}

      \item What variable(s) are defined in the {\tt estimatePi()} function?
        \hfill\ans[1.5in]{{\tt terms} and {\tt val}}

      \item What function is called by {\tt estimatePi()}?
        \hfill\ans[1.5in]{\tt estimatePi()}

      \item When {\tt estimatePi(0)} is called, what value is returned?
        \hfill\ans[1.5in]{\tt 0.0}

      \item When {\tt estimatePi(1)} is called, what function call is made on line 10?
        \hfill\ans[1.5in]{\tt estimatePi(0)}

      \item When {\tt estimatePi(1)} is called, what value is returned?
        \hfill\ans[1.5in]{\tt 4.0/1 + 0.0 = 4.0}

      \item When {\tt estimatePi(2)} is called, what function call is made on line 10?
        \hfill\ans[1.5in]{\tt estimatePi(1)}

      \item When {\tt estimatePi(2)} is called, what value is returned?
        \hfill\ans[1.5in]{\tt -4.0/3 + 4.0 = 2.6667}
    \end{enumerate}
      
  \Q A function that calls itself is called a {\it recursive}
    function.  While possibly confusing at first, recursive functions
    can be both powerful and flexible.  Which function(s) in the {\it
    Python} code above is recursive?
    \begin{answer}[0.5in]
      The function {\tt estimatePi()}
    \end{answer}

  \Q If recursive function {\it always} calls itself it will never
    end, and eventually the computer will run out of memory.  Situations
    when a recursive function {\it does} call itself are called {\it
    recursive cases} and those when it {\it does not} are called
    {\it base cases}.  What are the base and recursive cases
    for the function {\tt estimatePi()}?
    \begin{answer}[0.5in]
      The base case is when {\tt terms = 0}, everything else is a recursive case.
    \end{answer}

  \Q The {\it Scheme} language is a dialect of the {\it LISP}
    (short for LISt Processing) language,\key\\[-2.5mm] which was developed in the
    1970's by Guy Steele and Gerald Sussman for artificial intelligence.
    Ideally, in Scheme programs the value of a variable never changes,
    and functions always return something useful.  Thus, Scheme is
    called a {\it functional language}.  Scheme also uses {\it
    recursion} (functions that call themselves) instead of loops.
    Answer the following questions based on the {\it Scheme} code above.    
    \begin{enumerate}
      \itemsep 10pt
      \item What marks a comment in {\it Scheme}?
        \hfill\ans[1.5in]{\tt ;}

      \item What keyword assigns a value to a name?
        \hfill\ans[1.5in]{\tt define}  

      \item What keyword defines a function?
        \hfill\ans[1.5in]{\tt lambda}

      \item What expression subtracts 1 from {\tt terms}?
        \hfill\ans[1.5in]{\tt (- terms 1)}

      \item What expression checks whether {\tt terms} is odd?
        \hfill\ans[1.5in]{\tt (odd? terms) }

      \item If that expression evaluates to true, what value is returned?
        \hfill\ans[1.5in]{\tt +4}

      \item If that expression evaluates to false, what value is returned?
        \hfill\ans[1.5in]{\tt -4}

      \item When {\tt estimatePi(2)} is called, what function call is made?
        \hfill\ans[1.5in]{\tt estimatePi(1)}
    \end{enumerate}
    
  \Q You'll notice that Scheme uses parentheses quite a bit.  Some
    people jokingly claim that ``LISP'' stands for ``Lost In Stupid
    Parentheses''. How many pairs of parentheses are used in
    defining each of the functions {\tt estimatePi} and {\tt testEstimatePi}?
    \begin{answer}[0.75in]
      There are 11 pairs of parentheses in {\tt estimatePi} and 6 in {\tt testEstimatePi}.
    \end{answer}

  \Q An online {\tt Scheme} interpreter is available at
    \url{https://www.jdoodle.com/execute-scheme-online}.  Copy the Scheme code
    from {\tt activity19.scm} into this interpreter and run it. Then determine the 
    approximation of $\pi$ with 10000 terms by adding 10000 to the
    list of test values.
    \begin{answer}[1in]
      Change line 14 to \scheme{(define vals `(-1 0 1 2 10 100 10000))}
      and we get the estimate 3.131592035585537 with 10000 terms.
    \end{answer}