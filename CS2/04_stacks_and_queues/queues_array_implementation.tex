\model{Queues - Array Implementation}

  A queue ADT can be implemented in multiple ways, as you will see.
  For now, we will consider how to implement a queue using an array, e.g.:

  \begin{cpplst}
template<typename T>
class Queue {
private:
    T* data;      // array to store queue elements
    int capacity; // maximum size of queue
    int start;    // index of first element
    int end;      // index after last element

public:
    Queue(int maxSize) {
        this->capacity = maxSize;
        this->start = 0;
        this->end = 0;
        this->data = new T[maxSize];
    }

    // methods
};
  \end{cpplst}

  {\it\large Refer to Model 6 above as your team develops consensus answers
    to the questions below.}

  \quest{10 min}

  \Q Show the contents of the data array after each operation.
    Assume we start with an empty queue. If you use additional fields (e.g. to keep track
    of positions in the array),  add a column for each one and show how its value changes.
    \begin{center}
      \begin{tabular}{ |r|l|c|c|c|c|c|c|c| }
        \hline
        \rowcolor{lightgray} & \textbf{Operation}         & \textbf{[0]}  & \textbf{[1]}  & \textbf{[2]}  & \textbf{[3]}  & \ans[.2in]{} & \ans[.2in]{start} & \ans[.2in]{end} \\
        \hline
        a.                   & Create new data structure. & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{0}     & \ans[.2in]{0}   \\
        \hline
        b.                   & Add value 'A'.             & \ans[.2in]{A} & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{0}     & \ans[.2in]{1}   \\
        \hline
        c.                   & Add value 'B'.             & \ans[.2in]{A} & \ans[.2in]{B} & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{0}     & \ans[.2in]{2}   \\
        \hline
        d.                   & Remove value.              & \ans[.2in]{}  & \ans[.2in]{B} & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{1}     & \ans[.2in]{2}   \\
        \hline
        e.                   & Add value 'C'.             & \ans[.2in]{}  & \ans[.2in]{B} & \ans[.2in]{C} & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{1}     & \ans[.2in]{3}   \\
        \hline
        f.                   & Get current size.          & \ans[.2in]{}  & \ans[.2in]{B} & \ans[.2in]{C} & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{1}     & \ans[.2in]{3}   \\
        \hline
        g.                   & Remove value.              & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{C} & \ans[.2in]{}  & \ans[.2in]{} & \ans[.2in]{2}     & \ans[.2in]{3}   \\
        \hline
        h.                   & Add value 'D'.             & \ans[.2in]{}  & \ans[.2in]{}  & \ans[.2in]{C} & \ans[.2in]{D} & \ans[.2in]{} & \ans[.2in]{2}     & \ans[.2in]{4}   \\
        \hline
      \end{tabular}
    \end{center}

  \Q For each queue method, write a complete English sentence
    to describe \textbf{how it could\key\\[-2.5mm] be implemented} using an array, and its \textbf{O() performance}.

    Hint: Ideally, the methods should be O(1), or O(N) at worst.

    \begin{center}
      \renewcommand{\arraystretch}{2}
      \begin{tabular}{ |r|l|l|l| }
        \hline
        \rowcolor{lightgray} & \textbf{method}          & \textbf{implementation}                                          & \textbf{O()}  \\
        \hline
        a.                   & \ans[1.5in]{add or enqueue} & \ans[4in]{this.data[ this.end ] = value; this.end++;}               & \ans[.2in]{1} \\
        \hline
        b.                   & \ans[1.5in]{get}         & \ans[4in]{return this.data[ this.start ];}                      & \ans[.2in]{1} \\
        \hline
        c.                   & \ans[1.5in]{remove or dequeue}      & \ans[4in]{this.start++; return this.array[ this.start - 1 ];} & \ans[.2in]{1} \\
        \hline
        d.                   & \ans[1.5in]{}            & \ans[4in]{}                                                      & \ans[.2in]{}  \\
        \hline
        e.                   & \ans[1.5in]{}            & \ans[4in]{}                                                      & \ans[.2in]{}  \\
        \hline
      \end{tabular}
    \end{center}

  \Q For an array implementation, a queue is somewhat more difficult than a stack.
    Explain why this is the case and what extra thought is required to implement a queue.

    \begin{answer}[1in]
      A Stack adds and removes at the top, so the values at the bottom (array index 0) rarely change.
      A Queue adds at one end and removes at the other, so both ends change.
      If the head is at index 0, remove is O(N).
      A circular array is O(1) to add and remove, but more complex.
    \end{answer}

  Review progress with the facilitator before continuing.
    \begin{answer}[0.5in]
      see Facilitator - Sample Code
    
      REPORT OUT: implementation descriptions and O() performance, so teams have common framework
    \end{answer}

  \begin{quote}
    An Englishman, even if he is alone, forms an orderly queue of one.

    -- George Mikes, British writer, 1912-1987
  \end{quote}