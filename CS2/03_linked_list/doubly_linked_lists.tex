\model{Doubly linked lists}
  \quest{5 min}
  We can create a linked list struct like this:
  \begin{center}
    \centering {\bf C++ Code}\vskip -15pt\null
    \small
    \begin{cpplst}
typedef struct nodeTag Node;

struct nodeTag {
  int num;     // value stored in node
  Node * next; // pointer to next node in list
  Node * prev; // pointer to previous node in the list
};
    \end{cpplst}
  \end{center}

  This is called a \textit{doubly linked list}, since it has a link to the next item and a link to the previous item.
  What's nice about doubly linked lists is that they allow for forward and backward traversal. It does
  require more overhead â€“ each node has an extra field. Plus, for backward traversal to start at the end of
  the list, one must know the address of the last Node in the list.

  \Q  Suppose we had definitions for functions to create doubly linked lists and inserted the values 2, 4, and 6 (inserted at the back each time).
    What does the picture of a doubly linked list look like?\vskip 5pt
    \includegraphics[width=\textwidth]{figures/double_linked_fillin.png}

    \newpage

  \Q  Write the function definition for \texttt{numPos}.
    This function should return the number\key\\[-2.5mm] of items in the linked list (passed as a parameter) whose \texttt{num} value is greater than 0.
    \begin{answer}[2.5in]
      \begin{cpplst}
int numPos(Node *list) {
  int count = 0;
  Node *current = list;
  while (current != NULL) {
    if (current->num > 0) {
      count++;
    }
    current = current->next;
  }
  return count;
}
      \end{cpplst}
    \end{answer}

  \Q  If you wrote the function for \texttt{numPos} iteratively, try to write a recursive version.
    If you wrote it recursively, try to write it iteratively.
    \begin{answer}[1in]
      Answers will vary
    \end{answer}

  \Q  What questions does your group have about linked lists?
    \begin{answer}[1in]
      Answers will vary
    \end{answer}