\model{Comparing}

  In computing, we often need to \textbf{sort} a set of items. As computer scientists,
  we study ways to sort very large sets, with thousands or millions of values,
  since searching and other operations are often easier when the set of values is sorted.

  For example, the Harvard University Library has roughly 16,000,000 volumes, and the
  US Library of Congress has roughly 22,000,000 books, and over 100,000,000 total items.
  In 2010, a team at UC San Diego sorted one trillion ($10^{12}$) data records in 172 minutes.
  Simple $O(N^2)$ sorting algorithms work well for small lists, but are too slow for larger lists.
  Most software libraries (APIs) include excellent sorting algorithms,  but exploring better
  sorting algorithms also demonstrates more general concepts in algorithm design and analysis.

  \begin{cpplst}
void sort(int d[], int size);
void sort(string d[], int size);
void sort(City d[], int size);

void demo() {
    int iu[] = {6, 3, 8, 2, 9};
    int is[5];
    sort(iu, 5);
    string su[] = {"banana", "grape", "apple", "mango"};
    string ss[4];
    sort(su, 4);
    City cu[] = {City::NYC, City::LAX, City::PHL, City::CHI};
    City cs[4];
    sort(cu, 4);
}
  \end{cpplst}

  \par\vskip 10pt

  {\it\large Refer to Model 1 above as your team develops consensus answers
    to the questions below.}

  \quest{15 min}

  \Q Each \textbf{sort()} function above takes an array input and sorts it.
    What is \textbf{different} about the first 3 functions?
    \begin{answer}[0.6in]
      The 1st works on ints, the 2nd on strings; the 3rd on Cities.
    \end{answer}

  \Q What sequence of values should appear in each variable below:
    \begin{center}
      \renewcommand{\arraystretch}{2}
      \begin{tabular}{ |c|m{3cm}|m{11cm}| }
        \hline
        a. & is & \ans[4in]{is = \{2, 3, 6, 8, 9\}} \\
        \hline
        b. & ss & \ans[4in]{ss = \{"apple", "banana", "grape", "mango"\}} \\
        \hline
      \end{tabular}
    \end{center}

    \newpage

  \Q In the table below, specify tests for \textbf{sort()}:
    \begin{center}
      \renewcommand{\arraystretch}{2}
      \begin{tabular}{ |c|l|m{11cm}| }
        \hline
        \rowcolor{lightgray} & \textbf{Input: array to sort} & \textbf{Expected Result} \\
        \hline
        a. & [ ] (empty list) & empty list \\
        \hline
        b. & [ 5 ] & 5 \\
        \hline
        c. & [ 2, 4, 8 ] & \ans[4in]{\{2, 4, 8\}} \\
        \hline
        d. & [ 9, 7, 3, 5 ] & \ans[4in]{\{3, 5, 7, 9\}} \\
        \hline
        e. & [ 27, 42, 35 ] & \ans[4in]{\{27, 35, 42\}} \\
        \hline
        f. & [ "a" ] & \ans[4in]{\{a\}} \\
        \hline
        g. & [ "a", "b", "c" ] & \ans[4in]{\{a, b, c\}} \\
        \hline
        h. & [ "c", "b", "a" ] & \ans[4in]{\{a, b, c\}} \\
        \hline
        i. & [ "a3", "a1", "a2" ] & \ans[4in]{\{a1, a2, a3\}} \\
        \hline
        j. & [ "bar", "ball", "back" ] & \ans[4in]{\{back, ball, bar\}} \\
        \hline
      \end{tabular}
    \end{center}

  \Q It is easier to compare integers than strings. Explain why.
    \begin{answer}[0.6in]
      Integers have a single value, but strings have sets of character values.
      Integers have one clear ordering, but strings have upper/lower case, unusual characters, etc.
    \end{answer}

    Suppose we had a list (e.g. a database or spreadsheet) of detailed information about cities:
    \begin{center}
      \begin{tabular}{ |c|c|c|c|c|c| }
        \hline
        \rowcolor{lightgray} \textbf{Name} & \textbf{Area (sq mi)} & \textbf{Population} & \textbf{Altitude} & \textbf{Latitude} & \textbf{Longitude} \\
        \hline
        Chicago & 227.6 & 2,700,000 & ... & ... & ... \\
        \hline
        Los Angeles & 468.7 & 3,800,000 & ... & ... & ... \\
        \hline
        New York & 302.6 & 8,200,000 & ... & ... & ... \\
        \hline
        ... & ... & ... & ... & ... & ... \\
        \hline
      \end{tabular}
    \end{center}

  \vskip -30pt

  \Q Explain why it could be harder to compare Cities than strings.\key\\[-2.5mm]
    \begin{answer}[0.6in]
      Cities could be compared in many different ways - population, area, location, etc.
    \end{answer}

  \newpage

  \Q It can be useful to \textbf{abstract} the comparisons used in searching \& sorting.
    \begin{enumerate}
      \item In the \textbf{Sample Code} handout, what \textbf{function} is declared in the Comparable interface?
        \begin{answer}[0.6in]
          \texttt{int compareTo(const T\& that) const;}
        \end{answer}

      \item The C++ \texttt{std::copysign()} function (or custom signum) returns 0 if its input is 0,
        +1 if its input is positive, and -1 if its input is negative.
        In the Sample Code handout, how does class City compare two cities?
        \begin{answer}[0.6in]
          It subtracts their areas, and takes the signum of the result (-1, 0, +1).
        \end{answer}

      \item The C++ standard library class string provides comparison operators.
        Given this, what C++ expression would compare two strings: s1 and s2?
        \begin{answer}[0.6in]
          \texttt{s1.compare(s2)} or \texttt{s1 < s2}
        \end{answer}
    \end{enumerate}

  \vskip -40pt

  \Q In class City, modify the return statement to compare Cities using:\key\\[-2.5mm]
    \begin{center}
      \renewcommand{\arraystretch}{2}
      \begin{tabular}{ |c|m{2.3cm}|m{11cm}| }
        \hline
        a. & population & \ans[4in]{ return signum(this->getPop() - that.getPop()); } \\
        \hline
        b. & name (alphabetical) & \ans[4in]{ return this->getName().compare(that.getName()); } \\
        \hline
        c. & name (reverse alphabetical) & \ans[4in]{ return that.getName().compare(this->getName()); } \\
        \hline
        d. & population density & \ans[4in]{ return signum(this->getPop() / this->getArea() - that.getPop() / that.getArea()); } \\
        \hline
      \end{tabular}
    \end{center}

  \Q Comparison can be abstracted in more than one way.
    In the Sample Code handout, what functions are declared in the Comparator interface?
    \begin{answer}[0.6in]
      \texttt{int compare(const T\& o1, const T\& o2) const;} \\
      \texttt{bool equals(const Object\& obj) const;}
    \end{answer}

  \newpage

  \Q For each class listed below, describe how it compares 2 objects.
    \begin{center}
      \renewcommand{\arraystretch}{2}
      \begin{tabular}{ |c|m{2.3cm}|m{11cm}| }
        \hline
        a. & \texttt{class StringCompI} & \ans[4in]{ compares 2 strings alphabetically, ignoring uppercase/lowercase differences. } \\
        \hline
        b. & \texttt{class StringCompL} & \ans[4in]{ compares 2 strings using their length (not their contents) } \\
        \hline
        c. & \texttt{class CityCompA} & \ans[4in]{ compares 2 Cities using their area } \\
        \hline
        d. & \texttt{class CityCompP} & \ans[4in]{ compares 2 Cities using their population } \\
        \hline
      \end{tabular}
    \end{center}

  \Q Change the return statement in \texttt{CityCompA::compare()} to compare:
    \begin{center}
      \renewcommand{\arraystretch}{2}
      \begin{tabular}{ |c|m{2.3cm}|m{11cm}| }
        \hline
        a. & name (alphabetical) & \ans[4in]{ return c1.getName().compare(c2.getName()); } \\
        \hline
        b. & name (reverse alphabetical) & \ans[4in]{ return c2.getName().compare(c1.getName()); } \\
        \hline
        c. & population density & \ans[4in]{ return signum(c1.getPop() / c1.getArea() - c2.getPop() / c2.getArea()); } \\
        \hline
      \end{tabular}
    \end{center}