\model{Binary Trees}

  \quest{25 min}

  A tree is a fundamental data structure in computing.
  We generally draw trees with the root node at the top of the tree (upside-down from regular trees you see in nature).

  \par\vskip 10pt

  \includegraphics[width=.9\textwidth]{figures/trees_example.png}

  \textbf{Some more vocabulary about trees:}

  \textit{Children} are ordered left to right; a parent could have 0 or more children.

  A tree with 0 nodes is an \textit{empty} tree.

  \textit{Ancestors} of a node N are the nodes in the path from N to the root of the tree.

  \textit{Descendants} of a node N are the set of nodes that can be reached from any downward path from N.

  The \textit{height} of the tree is the number of nodes along the longest (deepest) path of the tree.
  The height of an empty tree is 0.

  The \textit{subtree} at node N is node N with all its descendants.

  \Q How could trees be useful for modeling data in computing applications?
    \begin{answer}[1in]
      Trees are useful for hierarchical data, file systems, class hierarchies, recursive structures, expression parsing, and decision trees.
    \end{answer}

  \newpage

  A \textbf{BINARY} tree is a tree in which each node has at most two children.
  Children are named left child or right child.

  Each node contains:\par\vskip 5pt

  \begin{tabular}{|l|}
    \hline
    Data (key,value) pairs if a dictionary \\ \hline
    Left child                             \\ \hline
    Right child                            \\ \hline
  \end{tabular}

  \begin{cpplst}
typedef int TreeData; // can change type with primitive or struct type
typedef struct TreeNodeTag TreeNode;

struct TreeNodeTag {
  TreeData value; // value stored in node
  TreeNode * left; // left child
  TreeNode * right; // right child
};
  \end{cpplst}

  The left child is a pointer to another tree node.
  The right child is a pointer to another tree node.
  For simplicity, we will store just one data item per node (but this data item could be a struct that contains key, value pairs).

  \par\vskip 10pt

  Suppose T is a binary tree, where each node has at most two children.

  \par\vskip -20pt

  \Q Draw a binary tree with 6 nodes (labeled A, B, C, D, E, F) where there are exactly\key\\[-2.5mm] 3 leaves.
    \begin{answer}[1.5in]
      Many solutions possible. Example: A as root with children B and C; B has children D and E; C has child F. Leaves are D, E, F.
    \end{answer}

  \par\vskip 5pt

  What is the height of your tree? \hfill\ans{3}

  \Q Draw a binary tree with 6 nodes where there is exactly 1 leaf.
    \begin{answer}[1.5in]
      A chain structure: A-B-C-D-E-F where each node has only one child. The last node (F) is the only leaf.
    \end{answer}

  \par\vskip 5pt

  What is the height of your tree? \hfill\ans{6}

  \newpage

  Assume a binary tree has height H.

  \Q What is the maximum \# of leaf nodes in a tree of height H?
    \begin{answer}[0.3in]
      $2^{H-1}$ leaves
    \end{answer}

  \Q What is the maximum \# of nodes in a tree of height H? (pack them in)
    \begin{answer}[0.3in]
      $2^H - 1$ nodes
    \end{answer}

  \Q What is the minimum \# of leaf nodes in a tree of height H?
    \begin{answer}[0.3in]
      1 leaf
    \end{answer}

  \Q What is the minimum \# of nodes in a tree of height H?
    \begin{answer}[0.3in]
      H nodes
    \end{answer}

  \par\vskip 10pt

  \textit{In general, trees only speed things up if the tree is ``full'', meaning that we have close to the maximum number of nodes in a tree for a given height.
    A long, skinny tree does not outperform a linked list.}

  \par\vskip 10pt

  Here is a binary tree of arithmetic expressions.

  \includegraphics[width=.4\textwidth]{figures/trees_arithmetic_expression.png}

  We can traverse the tree in one of three ways:
    \begin{itemize}
      \item Preorder: examine node, left subtree, right subtree
      \item Inorder: examine left subtree, node, right subtree
      \item Postorder: examine left subtree, right subtree, node
    \end{itemize}

  If you get confused about the names, think about \textbf{*when*} the node is examined. First (pre), Second (in), Third (post).

  In the example above, here are the orders of these traversals:

    \begin{itemize}
      \item Preorder: + x 2 5 4
      \item Inorder: 2 x 5 + 4
      \item Postorder: 2 5 x 4 +
    \end{itemize}

  Sometimes, the order of traversal does not matter for certain operations.
  For example, if you want to know how many nodes are in a tree, the way you traverse the tree does not impact your result.
  Any traversal would be fine.
  Sometimes, though, order does matter.
  If you want to print a tree such that each level of a tree is indented further to the right, you would want to examine the tree in preorder fashion.
  If you are evaluating an expression tree, such as the one above, you would want to do this in postorder (get value of children before processing new operator).

  Here is the code for inorder traversal. Note that visit is also defined for visiting the node.

  \begin{cpplst}
/* inorder
 * visits the nodes inorder (left, current, right) traversal
 */
void inorder(TreeNode * t) {
  if(t != NULL) {
    inorder(t->left);
    visit(t);
    inorder(t->right);
  }
}
  \end{cpplst}

  \Q Write the code to do preorder traversal:
    \begin{answer}[2in]
      \begin{cpplst}
void preorder(TreeNode * t) {
  if(t != NULL) {
    visit(t);
    preorder(t->left);
    preorder(t->right);
  }
}
      \end{cpplst}
    \end{answer}

  Suppose a tree has this structure:

  \includegraphics[width=.3\textwidth]{figures/trees3.png}

  \Q What is the inorder traversal of this tree? \hfill\ans{D, A, F, E, G, C, B}

  \Q What is the preorder traversal of this tree? \hfill\ans{C, A, D, E, F, G, B}

  \Q Write the recursive function to return the number of leaves in a tree.
    This should be written recursively, since the tree data structure is recursive.
    Recall that if t is null, there are no leaves.
    If it's right child and left child are both null, t is a leaf, so return 1.
    Else, add together the recursive calls to process the left subtree and right subtree.
    \begin{answer}[2in]
      \begin{cpplst}
int numLeaves(TreeNode * t) {
  if (t == NULL) {
    return 0;
  }
  if (t->left == NULL && t->right == NULL) {
    return 1;
  }
  return numLeaves(t->left) + numLeaves(t->right);
}
      \end{cpplst}
    \end{answer}

  \Q Write a function to count the number of interior nodes with two children.
    \begin{answer}[1.5in]
      \begin{cpplst}
int countTwoChildren(TreeNode * t) {
  if (t == NULL) {
    return 0;
  }
  int count = 0;
  if (t->left != NULL && t->right != NULL) {
    count = 1;
  }
  return count + countTwoChildren(t->left) + countTwoChildren(t->right);
}
      \end{cpplst}
    \end{answer}

  \Q Assume a binary tree is traversed in-order and preorder.
    Here is the output.
    What\key\\[-2.5mm] does the tree look like?

    Inorder: E F D B A C G H

    Preorder: D E F G A B C H

    \begin{answer}[1in]
      Root is D (first in preorder). In inorder, E F come before D and B A C G H come after.
      So left subtree has E, F and right subtree has B, A, C, G, H. Continue recursively to build the tree.
    \end{answer}

  \Q What questions does your group have about binary trees?\key\\[-2.5mm]
    \begin{answer}[0.5in]
      Answers will vary
    \end{answer}